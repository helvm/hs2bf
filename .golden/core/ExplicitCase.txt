data Test
    =Foo 1
    |Bar 0
    |Baz 0

data Bool
    =False 0
    |True 0

data Maybe
    =Nothing 0
    |Just 1

data Either
    =Left 1
    |Right 1

data Ordering
    =EQ 0
    |LT 0
    |GT 0

data XT1
    =XT1 1

data XT2
    =XT2 2

data XT3
    =XT3 3

data XList
    =XCons 2
    |XNil 0

data E
    =Input 1
    |Output 2
    |Halt 0

main=
    case Bar of
        Bar ->
            ((Output 111) Halt)
        Baz ->
            ((Output 120) Halt)
        Foo #xa ->
            let
                x = #xa
            in
                ((Output 42) Halt)

seq=
    undefined

undefined=
    undefined

addByteRaw=
    undefined

subByteRaw=
    undefined

cmpByteRaw=
    undefined

. #a0 #a1 #a2=
    case (((XT3 #a0) #a1) #a2) of
        XT3 #xa #xb #xc ->
            let
                f = #xa
            in
                let
                    g = #xb
                in
                    let
                        x = #xc
                    in
                        (f (g x))

$ #a0 #a1=
    case ((XT2 #a0) #a1) of
        XT2 #xa #xb ->
            let
                f = #xa
            in
                let
                    x = #xb
                in
                    (f x)

$! #a0 #a1=
    case ((XT2 #a0) #a1) of
        XT2 #xa #xb ->
            let
                f = #xa
            in
                let
                    x = #xb
                in
                    ((seq x) (f x))

id #a0=
    case (XT1 #a0) of
        XT1 #xa ->
            let
                x = #xa
            in
                x

flip #a0 #a1 #a2=
    case (((XT3 #a0) #a1) #a2) of
        XT3 #xa #xb #xc ->
            let
                f = #xa
            in
                let
                    x = #xb
                in
                    let
                        y = #xc
                    in
                        ((f y) x)

|| #a0 #a1=
    case ((XT2 #a0) #a1) of
        XT2 #xa #xb ->
            let
                x = #xa
            in
                let
                    y = #xb
                in
                    case x of
                        False ->
                            y
                        True ->
                            True

&& #a0 #a1=
    case ((XT2 #a0) #a1) of
        XT2 #xa #xb ->
            let
                x = #xa
            in
                let
                    y = #xb
                in
                    case x of
                        False ->
                            False
                        True ->
                            y

otherwise=
    True

head #a0=
    case (XT1 #a0) of
        XT1 #xa ->
            case #xa of
                XCons #xa #xb ->
                    let
                        x = #xa
                    in
                        let
                            xs = #xb
                        in
                            x

tail #a0=
    case (XT1 #a0) of
        XT1 #xa ->
            case #xa of
                XCons #xa #xb ->
                    let
                        x = #xa
                    in
                        let
                            xs = #xb
                        in
                            xs

reverse #a0=
    case (XT1 #a0) of
        XT1 #xa ->
            case #xa of
                 ->
                    case #xa of
                        XCons #xa #xb ->
                            let
                                x = #xa
                            in
                                let
                                    xs = #xb
                                in
                                    ((++ (reverse xs)) ((XCons x) XNil))
                XNil ->
                    XNil

map #a0 #a1=
    case ((XT2 #a0) #a1) of
        XT2 #xa #xb ->
            let
                f = #xa
            in
                case #xb of
                     ->
                        let
                            f = #xa
                        in
                            case #xb of
                                XCons #xa #xb ->
                                    let
                                        x = #xa
                                    in
                                        let
                                            xs = #xb
                                        in
                                            ((XCons (f x)) ((map f) xs))
                    XNil ->
                        XNil

filter #a0 #a1=
    case ((XT2 #a0) #a1) of
        XT2 #xa #xb ->
            let
                f = #xa
            in
                case #xb of
                     ->
                        let
                            f = #xa
                        in
                            case #xb of
                                XCons #xa #xb ->
                                    let
                                        x = #xa
                                    in
                                        let
                                            xs = #xb
                                        in
                                            case (f x) of
                                                False ->
                                                    case otherwise of
                                                        False ->
                                                            undefined
                                                        True ->
                                                            ((filter f) xs)
                                                True ->
                                                    ((XCons x) ((filter f) xs))
                    XNil ->
                        XNil

!! #a0 #a1=
    case ((XT2 #a0) #a1) of
        XT2 #xa #xb ->
            case #xa of
                XCons #xa #xb ->
                    let
                        x = #xa
                    in
                        let
                            xs = #xb
                        in
                            let
                                n = #xb
                            in
                                case ((eqByte n) 0) of
                                    False ->
                                        case otherwise of
                                            False ->
                                                undefined
                                            True ->
                                                ((!! xs) ((subByte n) 1))
                                    True ->
                                        x

++ #a0 #a1=
    case ((XT2 #a0) #a1) of
        XT2 #xa #xb ->
            let
                xs = #xa
            in
                let
                    ys = #xb
                in
                    case xs of
                        XCons #xa #xb ->
                            let
                                x = #xa
                            in
                                let
                                    xs = #xb
                                in
                                    ((XCons x) ((++ xs) ys))
                        XNil ->
                            ys

length #a0=
    case (XT1 #a0) of
        XT1 #xa ->
            case #xa of
                 ->
                    case #xa of
                        XCons #xa #xb ->
                            let
                                x = #xa
                            in
                                let
                                    xs = #xb
                                in
                                    ((addByte 1) (length xs))
                XNil ->
                    0

foldr #a0 #a1 #a2=
    case (((XT3 #a0) #a1) #a2) of
        XT3 #xa #xb #xc ->
            let
                f = #xa
            in
                let
                    z = #xb
                in
                    case #xc of
                         ->
                            let
                                f = #xa
                            in
                                let
                                    z = #xb
                                in
                                    case #xc of
                                        XCons #xa #xb ->
                                            let
                                                x = #xa
                                            in
                                                let
                                                    xs = #xb
                                                in
                                                    ((f x) (((foldr f) z) xs))
                        XNil ->
                            z

foldl #a0 #a1 #a2=
    case (((XT3 #a0) #a1) #a2) of
        XT3 #xa #xb #xc ->
            let
                f = #xa
            in
                let
                    z = #xb
                in
                    case #xc of
                         ->
                            let
                                f = #xa
                            in
                                let
                                    z = #xb
                                in
                                    case #xc of
                                        XCons #xa #xb ->
                                            let
                                                x = #xa
                                            in
                                                let
                                                    xs = #xb
                                                in
                                                    (((foldl f) ((f x) z)) xs)
                        XNil ->
                            z

addByte #a0 #a1=
    case ((XT2 #a0) #a1) of
        XT2 #xa #xb ->
            let
                x = #xa
            in
                let
                    y = #xb
                in
                    ((seq x) ((seq y) ((addByteRaw x) y)))

subByte #a0 #a1=
    case ((XT2 #a0) #a1) of
        XT2 #xa #xb ->
            let
                x = #xa
            in
                let
                    y = #xb
                in
                    ((seq x) ((seq y) ((subByteRaw x) y)))

cmpByte #a0 #a1=
    case ((XT2 #a0) #a1) of
        XT2 #xa #xb ->
            let
                x = #xa
            in
                let
                    y = #xb
                in
                    ((seq x) ((seq y) ((cmpByteRaw x) y)))

eqByte #a0 #a1=
    case ((XT2 #a0) #a1) of
        XT2 #xa #xb ->
            let
                x = #xa
            in
                let
                    y = #xb
                in
                    let
                        s = ((cmpByte x) y)
                    in
                        case s of
                             ->
                                False
                            EQ ->
                                True

ltByte #a0 #a1=
    case ((XT2 #a0) #a1) of
        XT2 #xa #xb ->
            let
                x = #xa
            in
                let
                    y = #xb
                in
                    let
                        s = ((cmpByte x) y)
                    in
                        case s of
                             ->
                                False
                            LT ->
                                True

gtByte #a0 #a1=
    case ((XT2 #a0) #a1) of
        XT2 #xa #xb ->
            let
                x = #xa
            in
                let
                    y = #xb
                in
                    let
                        s = ((cmpByte x) y)
                    in
                        case s of
                             ->
                                False
                            GT ->
                                True

leByte #a0 #a1=
    case ((XT2 #a0) #a1) of
        XT2 #xa #xb ->
            let
                x = #xa
            in
                let
                    y = #xb
                in
                    let
                        s = ((cmpByte x) y)
                    in
                        case s of
                             ->
                                True
                            GT ->
                                False

geByte #a0 #a1=
    case ((XT2 #a0) #a1) of
        XT2 #xa #xb ->
            let
                x = #xa
            in
                let
                    y = #xb
                in
                    let
                        s = ((cmpByte x) y)
                    in
                        case s of
                             ->
                                True
                            LT ->
                                False
