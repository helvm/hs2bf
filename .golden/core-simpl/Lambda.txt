data Bool
    =False 0
    |True 0

data Maybe
    =Nothing 0
    |Just 1

data Either
    =Left 1
    |Right 1

data Ordering
    =EQ 0
    |LT 0
    |GT 0

data XT1
    =XT1 1

data XT2
    =XT2 2

data XT3
    =XT3 3

data XList
    =XCons 2
    |XNil 0

data E
    =Input 1
    |Output 2
    |Halt 0

main=
    letrec
        ch_ = 65
    in
        (((_l_main_ ch_) Halt) main)

_l_main_ ch_ x_aaa y_aaa=
    ((Output ch_) x_aaa)

seq=
    undefined

undefined=
    undefined

addByteRaw=
    undefined

subByteRaw=
    undefined

cmpByteRaw=
    undefined

. #a0_ #a1_ #a2_=
    case (((XT3 #a0_) #a1_) #a2_) of
        XT3 #xa_ #xb_ #xc_ ->
            (#xa_ (#xb_ #xc_))

$ #a0_ #a1_=
    case ((XT2 #a0_) #a1_) of
        XT2 #xa_ #xb_ ->
            (#xa_ #xb_)

$! #a0_ #a1_=
    case ((XT2 #a0_) #a1_) of
        XT2 #xa_ #xb_ ->
            ((seq #xb_) (#xa_ #xb_))

id #a0_=
    case (XT1 #a0_) of
        XT1 #xa_ ->
            #xa_

flip #a0_ #a1_ #a2_=
    case (((XT3 #a0_) #a1_) #a2_) of
        XT3 #xa_ #xb_ #xc_ ->
            ((#xa_ #xc_) #xb_)

|| #a0_ #a1_=
    case ((XT2 #a0_) #a1_) of
        XT2 #xa_ #xb_ ->
            case #xa_ of
                False ->
                    #xb_
                True ->
                    True

&& #a0_ #a1_=
    case ((XT2 #a0_) #a1_) of
        XT2 #xa_ #xb_ ->
            case #xa_ of
                False ->
                    False
                True ->
                    #xb_

otherwise=
    True

head #a0_=
    case (XT1 #a0_) of
        XT1 #xa_ ->
            case #xa_ of
                XCons #xa_b #xb_b ->
                    #xa_b

tail #a0_=
    case (XT1 #a0_) of
        XT1 #xa_ ->
            case #xa_ of
                XCons #xa_b #xb_b ->
                    #xb_b

reverse #a0_=
    case (XT1 #a0_) of
        XT1 #xa_ ->
            case #xa_ of
                XCons _b _b ->
                    case #xa_ of
                        XCons #xa_bb #xb_bb ->
                            ((++ (reverse #xb_bb)) ((XCons #xa_bb) XNil))
                XNil ->
                    XNil

map #a0_ #a1_=
    case ((XT2 #a0_) #a1_) of
        XT2 #xa_ #xb_ ->
            case #xb_ of
                XCons _ba _ba ->
                    case #xb_ of
                        XCons #xa_baba #xb_baba ->
                            ((XCons (#xa_ #xa_baba)) ((map #xa_) #xb_baba))
                XNil ->
                    XNil

filter #a0_ #a1_=
    case ((XT2 #a0_) #a1_) of
        XT2 #xa_ #xb_ ->
            case #xb_ of
                XCons _ba _ba ->
                    case #xb_ of
                        XCons #xa_baba #xb_baba ->
                            case (#xa_ #xa_baba) of
                                False ->
                                    case otherwise of
                                        False ->
                                            undefined
                                        True ->
                                            ((filter #xa_) #xb_baba)
                                True ->
                                    ((XCons #xa_baba) ((filter #xa_) #xb_baba))
                XNil ->
                    XNil

!! #a0_ #a1_=
    case ((XT2 #a0_) #a1_) of
        XT2 #xa_ #xb_ ->
            case #xa_ of
                XCons #xa_b #xb_b ->
                    case ((eqByte #xb_b) 0) of
                        False ->
                            case otherwise of
                                False ->
                                    undefined
                                True ->
                                    ((!! #xb_b) ((subByte #xb_b) 1))
                        True ->
                            #xa_b

++ #a0_ #a1_=
    case ((XT2 #a0_) #a1_) of
        XT2 #xa_ #xb_ ->
            case #xa_ of
                XCons #xa_baa #xb_baa ->
                    ((XCons #xa_baa) ((++ #xb_baa) #xb_))
                XNil ->
                    #xb_

length #a0_=
    case (XT1 #a0_) of
        XT1 #xa_ ->
            case #xa_ of
                XCons _b _b ->
                    case #xa_ of
                        XCons #xa_bb #xb_bb ->
                            ((addByte 1) (length #xb_bb))
                XNil ->
                    0

foldr #a0_ #a1_ #a2_=
    case (((XT3 #a0_) #a1_) #a2_) of
        XT3 #xa_ #xb_ #xc_ ->
            case #xc_ of
                XCons _baa _baa ->
                    case #xc_ of
                        XCons #xa_baabaa #xb_baabaa ->
                            ((#xa_ #xa_baabaa) (((foldr #xa_) #xb_) #xb_baabaa))
                XNil ->
                    #xb_

foldl #a0_ #a1_ #a2_=
    case (((XT3 #a0_) #a1_) #a2_) of
        XT3 #xa_ #xb_ #xc_ ->
            case #xc_ of
                XCons _baa _baa ->
                    case #xc_ of
                        XCons #xa_baabaa #xb_baabaa ->
                            (((foldl #xa_) ((#xa_ #xa_baabaa) #xb_)) #xb_baabaa)
                XNil ->
                    #xb_

addByte #a0_ #a1_=
    case ((XT2 #a0_) #a1_) of
        XT2 #xa_ #xb_ ->
            ((seq #xa_) ((seq #xb_) ((addByteRaw #xa_) #xb_)))

subByte #a0_ #a1_=
    case ((XT2 #a0_) #a1_) of
        XT2 #xa_ #xb_ ->
            ((seq #xa_) ((seq #xb_) ((subByteRaw #xa_) #xb_)))

cmpByte #a0_ #a1_=
    case ((XT2 #a0_) #a1_) of
        XT2 #xa_ #xb_ ->
            ((seq #xa_) ((seq #xb_) ((cmpByteRaw #xa_) #xb_)))

eqByte #a0_ #a1_=
    case ((XT2 #a0_) #a1_) of
        XT2 #xa_ #xb_ ->
            let
                s_baa = ((cmpByte #xa_) #xb_)
            in
                case s_baa of
                    GT ->
                        False
                    LT ->
                        False
                    EQ ->
                        True

ltByte #a0_ #a1_=
    case ((XT2 #a0_) #a1_) of
        XT2 #xa_ #xb_ ->
            let
                s_baa = ((cmpByte #xa_) #xb_)
            in
                case s_baa of
                    EQ ->
                        False
                    GT ->
                        False
                    LT ->
                        True

gtByte #a0_ #a1_=
    case ((XT2 #a0_) #a1_) of
        XT2 #xa_ #xb_ ->
            let
                s_baa = ((cmpByte #xa_) #xb_)
            in
                case s_baa of
                    EQ ->
                        False
                    LT ->
                        False
                    GT ->
                        True

leByte #a0_ #a1_=
    case ((XT2 #a0_) #a1_) of
        XT2 #xa_ #xb_ ->
            let
                s_baa = ((cmpByte #xa_) #xb_)
            in
                case s_baa of
                    EQ ->
                        True
                    LT ->
                        True
                    GT ->
                        False

geByte #a0_ #a1_=
    case ((XT2 #a0_) #a1_) of
        XT2 #xa_ #xb_ ->
            let
                s_baa = ((cmpByte #xa_) #xb_)
            in
                case s_baa of
                    EQ ->
                        True
                    GT ->
                        True
                    LT ->
                        False
